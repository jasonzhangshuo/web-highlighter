# Web Highlighter 问题说明与关键文件

## 一、现象与原因

### 现象

1. **Dashboard 被刷爆**：高亮条数在短时间内暴增（数千到近万条），电脑卡顿。
2. **重复展示**：同一段内容在 dashboard 里出现很多条，甚至一刷新就继续增加。
3. **与手动刷新无关**：即使用户不刷新页面，后台也在不断写入新记录。

### 原因归纳

| 原因 | 说明 |
|------|------|
| **1. 扩展在多个 frame 里跑** | `manifest.json` 里 `all_frames: true`，主页面 + 所有 iframe 都会注入 content script。微信读书阅读区在 iframe 里，主页面和 iframe 都会收到同一次「复制」事件，各自发一次保存请求 → 同一条被保存多次。 |
| **2. 监听「复制」时 clipboard 为空** | 微信读书点「复制」时，`copy` 事件在**捕获阶段**先被我们收到，此时 `e.clipboardData.getData('text/plain')` 常为空（他们稍后才写入）。后来改为用 `window.getSelection().toString()` 取选区文字才稳定。 |
| **3. 拦截了页面的 fetch** | 扩展在页面里注入脚本，包装了 `window.fetch`。当请求 URL 包含 `review` / `highlight` / `mark` / `annotation` / `note` 且带 body 时，会解析 body 并 postMessage 给 content script 去保存。微信读书会**频繁**请求自己的划线/笔记接口，每次请求都触发我们保存 → 疯狂写入、重复进入。 |
| **4. DOM 扫描 + 定时器** | 曾用 MutationObserver + 每 5 秒 `querySelectorAll` 扫描「像高亮」的节点并保存。微信读书 DOM 里大量 span 带 background 或 class，被误判为高亮；且每个 iframe 各自扫、各自保存，没有跨 frame 去重 → 短时间内写入大量重复。 |
| **5. 扩展在 dashboard 页也运行** | 若用户开着 `http://localhost:3100/dashboard`，content script 也会在该页注入。若该页有复制等行为，会往自己的 API 发请求，增加混乱。 |

### 已做的修复（供对照）

- 微信读书下**不再**做 DOM 扫描 / 定时器，只做「复制即保存」。
- 微信读书下**不再**注入 fetch 拦截脚本，避免随他们的接口请求刷保存。
- 复制时优先用 `getSelection().toString()`，辅以 `clipboardData`。
- 复制防抖：本帧内 3 秒内同一段文字只处理一次（`_lastText` / `_lastTime`），再用 `chrome.storage.local` 做跨 frame 去重。
- 在 content 脚本最前判断：若当前页为 `localhost:3100`（dashboard）则直接 return，不执行任何逻辑。
- 服务端 POST `/api/highlights` 去重：同一 url + 同一 text 在 60 秒内已存在则不再插入，直接返回 201。

---

## 二、项目关键脚本文件

以下文件与「高亮抓取、保存、去重、刷爆问题」直接相关，便于用其他工具检查。

### 扩展（Chrome Extension）

| 文件 | 作用 |
|------|------|
| `extension/manifest.json` | 声明 `content_scripts` 的 `matches`、`all_frames` 等；`host_permissions` 含 `http://localhost:3100/*`。 |
| `extension/content.js` | **核心逻辑**：是否在 dashboard 跳过、复制监听、getSelection/clipboardData、防抖（内存 + storage）、是否注入 fetch、是否在微信读书下跳过 DOM 观察与定时器、调用 `saveToServer`。 |

### 微信读书「复制即保存」（独立逻辑）

- 微信读书网页**屏蔽右键**，无法用「保存到 Web Highlighter」菜单，因此**仅依赖复制事件**。
- 在 `content.js` 中：当 `IS_WEREAD`（host 为 weread.qq.com）时，**只**注册 `document.addEventListener('copy', ..., true)`，用「当前选区」或剪贴板取文，防抖后调用 `saveToServer(text, '')`。逻辑与 **main 分支**一致（仅本 frame 的 `getSelection().toString()` + `clipboardData`）。
- 不注入 fetch 包装、不跑 DOM 扫描，避免刷屏；去重依赖本帧 3 秒 + `chrome.storage.local` 跨 frame。
- 若失效：确认扩展在 weread.qq.com 有权限、本地服务已启动；在控制台看是否有 `[Web Highlighter] 已加载，仅「复制」时保存`。

### 服务端

| 文件 | 作用 |
|------|------|
| `server/server.js` | 提供 `GET/POST/PUT/DELETE /api/highlights`、`GET /api/export`、`GET /api/stats`；POST 时的去重逻辑 `isDuplicate`、`DEDUPE_SEC`；读写 `database.json`。 |
| `server/database.json` | 持久化存储，结构为 `{ "highlights": [ { id, text, note, url, title, domain, timestamp }, ... ] }`。 |

### 前端 Dashboard

| 文件 | 作用 |
|------|------|
| `server/public/index.html` | 管理页：请求 `/api/highlights` 和 `/api/stats`，渲染列表，搜索、导出、删除；内含 `setInterval(loadHighlights, 30000)` 每 30 秒拉一次。 |

### 辅助脚本（非扩展、非服务端主流程）

| 文件 | 作用 |
|------|------|
| `scripts/weread-copy-listener.js` | Playwright 脚本：打开微信读书、注入复制监听、在终端打印 `[检测] 复制事件触发`，用于验证「复制」是否被我们收到、当时 clipboard 是否为空。 |

---

## 三、建议检查点（给其他工具 / 人工复查）

1. **extension/content.js**
   - 最前面是否有 `localhost:3100` 直接 return。
   - 复制回调里是否先读 `getSelection().toString()`，再 `clipboardData`。
   - 是否有 `_lastText` / `_lastTime` 的同步防抖，以及 `chrome.storage.local` 的跨 frame 防抖。
   - `IS_WEREAD` 为 true 时是否未注入 fetch 包装脚本、未启动 observer/ setInterval。
2. **server/server.js**
   - POST `/api/highlights` 是否在 push 前按 `url + text + 60 秒` 去重。
3. **extension/manifest.json**
   - `all_frames: true` 是否仍需要（保留则需依赖扩展内与服务端双重防抖）。

以上内容可直接交给其他工具做静态检查或人工排查。
